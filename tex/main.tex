\documentclass[journal]{IEEEtran}
\renewcommand{\IEEEkeywordsname}{Keywords}

\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\setlength{\marginparwidth}{2cm}
\usepackage[italian, textsize=small, textwidth=2cm]{todonotes}

\usepackage{hyperref}
\usepackage{url}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}

\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=2.5cm, minimum height=0.8cm, text centered, draw=black, fill=red!30]
\tikzstyle{process} = [rectangle, minimum width=2.5cm, minimum height=0.8cm, text centered, draw=black, fill=blue!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\usepackage[dvipsnames]{xcolor}
\usepackage{listings}
\renewcommand{\lstlistingname}{Codice}
\lstdefinestyle{asp}{
  language=Prolog, % Linguaggio di base simile ad ASP
  basicstyle=\ttfamily\small, % Font monospaziato
  keywordstyle=\color{Blue}\bfseries, % Parole chiave in grassetto blu
  commentstyle=\color{green!50!black}, % Commenti in verde
  stringstyle=\color{orange}, % Stringhe in arancione
  numbers=left, % Numeri di riga a sinistra
  numberstyle=\tiny, % Stile numeri di riga
  numbersep=5pt, % Spaziatura dei numeri di riga
	%  frame=single, % Cornice intorno al blocco di codice
	% framerule=0.1pt,
	linewidth=0.98\columnwidth,
  breaklines=true, % Interruzione automatica delle righe lunghe
  captionpos=b, % Posizione della didascalia sotto il blocco
	sensitive=true,
  morekeywords={:-, :, {, }, \#show, garante, docente, corso, afferisce, categoria_corso,
                insegna, insegnamento, ricercatore, contratto, indeterminato,
                settore, di_riferimento, min_garanti, max_garanti, min_indeterminato,
                max_ricercatori, max_contratto, min_riferimento, ideale,
								non_ideale
	},
	backgroundcolor=\color{lightgray!20},
}


\begin{document}

\title{Ottimizzazione Garanti accademici}

\author{\IEEEauthorblockN{Manuel Di Agostino}
\IEEEauthorblockA{\textit{Università degli studi di Parma} \\
Parma, Italia\\
manuel.diagostino@studenti.unipr.it}\\

\IEEEauthorblockN{Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
}

\maketitle

\begin{abstract} 
	La gestione dell'assegnazione dei docenti di riferimento o
	garanti in ambito universitario è un compito complesso che coinvolge vari
	fattori organizzativi e un gran numero di dati. L'automazione di questo
	processo può semplificare notevolmente il lavoro amministrativo e migliorare
	l'efficienza operativa delle università. È stato sviluppato un sistema basato
	su \textit{Answer Set Programming} (ASP), un paradigma logico adatto alla
	risoluzione di problemi combinatori complessi. Utilizzando \texttt{Python} e
	\texttt{Clingo}, un potente solver ASP,  è stata progettata una soluzione
	capace di identificare automaticamente i docenti di riferimento, a partire da
	un insieme di dati specifici. Il sistema sviluppato è descritto nei suoi
	dettagli tecnici, con un focus sulla modellazione logica, l'implementazione e
	l'analisi della complessità computazionale. I risultati ottenuti sono discussi
	insieme alle potenzialità di estensione del sistema.
\end{abstract}

\begin{IEEEkeywords}
Answer Set Programming, Ottimizzazione, Programmazione Dichiarativa, Clingo
\end{IEEEkeywords}

\section{Introduzione} L'identificazione dei docenti di riferimento o garanti
per uno specifico corso di studi rappresenta un processo che annualmente
coinvolge le università italiane. Tale compito può risultare complesso,
specialmente in presenza di strutture organizzative articolate e di grandi
volumi di dati. La necessità di automatizzare e ottimizzare questa ricerca è
quindi cruciale per migliorare l'efficienza delle attività amministrative e
accademiche.

In questo progetto, il problema è stato affrontato utilizzando \textit{Answer
Set Programming} (ASP), un paradigma di programmazione logica dichiarativa
particolarmente adatto alla risoluzione di problemi combinatori complessi.
L'implementazione è stata realizzata con l'ausilio di \texttt{Python}
\cite{python} e \texttt{Clingo} \cite{clingo}, un solver open source ASP che
combina il modello di programmazione logica con strumenti di ottimizzazione
efficienti.

L'obiettivo principale è stato quello di progettare e implementare un sistema
che, a partire da un insieme di dati resi disponibili dagli uffici di
competenza, consenta di individuare in maniera automatica i docenti di
riferimento o garanti in base a criteri specifici. La relazione descrive le fasi
del lavoro, dall'analisi dei requisiti del problema alla modellazione logica,
presentando i dettagli dell'implementazione concreta e un'analisi sulla sua
complessità computazionale. Infine, vengono discussi i risultati ottenuti e le
possibili estensioni del progetto.


\section{Background}
\subsection{Motivazioni}
Attualmente, l'Università di Parma gestisce l'assegnazione dei docenti in modo
manuale, affrontando il processo in maniera incrementale per ciascun corso di
laurea. Il personale incaricato impiega settimane per ottenere una versione
soddisfacente della distribuzione, basandosi frequentemente su preferenze
informali e criteri non documentati. Questo approccio risulta poco flessibile e
difficilmente adattabile a nuove esigenze. Inoltre, presenta significative
limitazioni, come la difficoltà nel gestire situazioni complesse e l'incapacità
di ottimizzare il processo in tempo reale, rendendo il sistema poco efficiente e
reattivo ai cambiamenti.

\subsection{Answer Set Programming}
L'Answer Set Programming (ASP) è un paradigma di programmazione logica
dichiarativa, particolarmente adatto per risolvere problemi complessi di natura
combinatoria che richiedono soluzioni flessibili e ottimizzate. A differenza
della programmazione imperativa tradizionale, ASP si concentra sulla descrizione
del \textit{cosa} deve essere risolto piuttosto che su	\textit{come} farlo,
utilizzando una forma di logica che rappresenta le conoscenze del problema e le
sue restrizioni (\textit{vincoli}).

ASP si basa sulla teoria degli \textit{answer sets}, ossia un insieme di atomi
letterali consistenti con le regole e i fatti che costituiscono il programma. Il
compito del solver ASP è quello di trovare gli insiemi di valori che risolvono
il sistema di equazioni logiche, fornendo così soluzioni ottimali o ammissibili.

L'uso di questo paradigma di programmazione è particolarmente indicato in ambiti in cui sono presenti vincoli complessi, preferenze multiple e
soluzioni che devono rispettare determinati criteri. ASP permette di modellare
in modo naturale problemi che coinvolgono l'ottimizzazione, la pianificazione, e
la ricerca di soluzioni in scenari combinatori, in cui le variabili e le
relazioni tra esse sono numerose e intricate.

\subsection{Il solver}
\texttt{Clingo} \cite{clingo} è un solver open-source per ASP, sviluppato dal gruppo Potassco.
È uno degli strumenti più potenti e diffusi per risolvere problemi complessi di
ottimizzazione e combinazione, combinando un motore di inferenza logica con
capacità avanzate di ottimizzazione. Nel nostro progetto, è stato integrato
direttamente in Python utilizzando le API Python ufficiali
\cite{clingo_python_api}, le quali consentono di interagire facilmente con il
solver all'interno di ambienti Python. Questa integrazione permette di
automatizzare il processo di invocazione e gestione delle soluzioni, facilitando
l'elaborazione dei dati e l'ottimizzazione delle assegnazioni in tempo reale.

\subsection{Provenienza e contenuto dei dati di input}

I dati di input sono stati forniti dall'U.O. Progettazione Didattica e
Assicurazione della Qualità \cite{unipr_qualita}, in collaborazione con il prof.
A. Dal Palù dell'Università di Parma. Questi includono un insieme di tabelle e
documenti eterogenei, comprendenti le coperture dei corsi per l'anno accademico
corrente, l'elenco del personale docente e le informazioni relative alle
immatricolazioni nei corsi di laurea. L'elaborazione è stata effettuata
utilizzando \texttt{Python} e si è rivelata particolarmente complessa a causa
dell'assenza di una sorgente dati unica e centralizzata.

\section{Modellazione del problema}

\subsection{Esempio giocattolo}


\subsection{Strutturazione della soluzione}

\begin{figure}[ht]
\centering
\begin{tikzpicture}[node distance=1.2cm]

% Nodes
\node (start) [startstop] {Inizio};
	\node (process1) [process, below of=start] {Elaborazione dati (Python)};
	\node (generate) [process, below of=process1] {Generazione fatti ground (Python)};
\node (solve) [process, below of=generate] {Solver Clingo (Python API + ASP)};
	\node (output) [process, below of=solve] {Generazione tabella garanti (Python)};
\node (end) [startstop, below of=output] {Fine};

% Arrows
\draw [arrow] (start) -- (process1);
\draw [arrow] (process1) -- (generate);
\draw [arrow] (generate) -- (solve);
\draw [arrow] (solve) -- (output);
\draw [arrow] (output) -- (end);

\end{tikzpicture}
\caption{Pipeline del processo di assegnazione dei garanti.}
\label{fig:pipeline}
\end{figure}

In Fig. \ref{fig:pipeline}
è illustrata la
pipeline di lavoro. Prima dell'elaborazione automatica dei dati, è stato
necessario effettuarne una normalizzazione manuale. Questo passaggio ha permesso
di uniformare i formati e risolvere eventuali incongruenze nei dati forniti,
facilitando così le fasi successive. La generazione dei fatti ground costituisce
la base di conoscenza positiva, utilizzata dal programma ASP principale per
calcolare gli answer set. Successivamente, il solver Clingo viene eseguito
tramite Python e i risultati ottenuti vengono convertiti in formato tabellare
per facilitarne la visualizzazione.

\subsection{Implementazione}

L'implementazione è stata progettata separando la logica principale per la
generazione dei garanti accademici da quella relativa alle preferenze
specifiche. Tra le preferenze considerate figurano:  \begin{itemize} \item
	assegnazione automatica del ruolo di garante al presidente del corso;  \item
massimizzazione del numero di docenti con contratto a tempo indeterminato;
\item minimizzazione del numero di ricercatori e docenti a contratto coinvolti.
\end{itemize}

Nel Cod. \ref{lst:mainlp} viene illustrato il codice di \texttt{main.lp}. Per
questioni di ottimizzazione in fase di grounding si è preferito, ove possibile, utilizzare gli
\textit{aggregati} evitando così l'utilizzo della negazione esplicita.

\begin{center}
\begin{lstlisting}[style=asp, caption={Codice ASP del file \texttt{main.lp}.}, label={lst:mainlp}]
% se garante allora insegna almeno una materia
1 {
    insegnamento(I) : insegna(docente(Matricola), insegnamento(I), corso(Corso))
} :-
    garante(docente(Matricola), corso(Corso)).

% numero garanti
M {
    garante(docente(Matricola), corso(Corso)) :
    docente(Matricola)
} N :-
    min_garanti(M, corso(Corso)),
    max_garanti(N, corso(Corso)),
    corso(Corso),
    afferisce(corso(Corso), categoria_corso(Categoria)).

% almeno X garanti a tempo indeterminato
X {
    garante(docente(Matricola), corso(Corso)) :
    garante(docente(Matricola), corso(Corso)),
    indeterminato(docente(Matricola))
} :-
    min_indeterminato(X, corso(Corso)),
    corso(Corso),
    afferisce(corso(Corso), categoria_corso(Categoria)).

% al piu' X garanti ricercatore
% (analogo al precedente)

% al piu' X garanti a contratto
% (analogo al precedente)

% un docente scelto al piu' una volta
1 {
    garante(docente(Matricola), corso(Corso2)) :
    corso(Corso2),
    afferisce(corso(Corso2), categoria_corso(Categoria2))
} 1 :-
    garante(docente(Matricola), corso(Corso1)),
    afferisce(corso(Corso1), categoria_corso(Categoria1)).

R {
    garante(docente(Matricola), corso(Corso)) :
    garante(docente(Matricola), corso(Corso)),
    afferisce(docente(Matricola), settore(Settore)),
    di_riferimento(settore(Settore), corso(Corso))
} :-
    corso(Corso),
    min_riferimento(R, corso(Corso)).

#show garante/2.
\end{lstlisting}
\end{center}

Le preferenze (Cod. \ref{lst:preferenzelp}) sono state espresse tramite l'utilizzo di \textit{weak constraint}. In particolare, sono stati definiti quattro livelli di priorità\footnote{Si ricorda che l'ordine di importanza è inverso rispetto al livello di priorità indicato.} sui quali intervenire:
\begin{itemize}
    \item priorità 4: massimizzare l'assegnazione dei presidenti di corso come garanti;
    \item priorità 3: massimizzare il numero di corsi per i quali è soddisfatto il predicato \texttt{ideale/1}, dove i garanti sono esclusivamente docenti a contratto indeterminato;
    \item priorità 2: massimizzare l'impiego di docenti a contratto indeterminato come garanti;
    \item priorità 1: minimizzare il numero di corsi per i quali è soddisfatto il predicato \texttt{non\_ideale/1}, i cui garanti comprendono almeno un ricercatore e/o un docente a contratto a tempo determinato.
\end{itemize}

\begin{center}
\begin{lstlisting}[style=asp, caption={Codice ASP del file \texttt{preferenze.lp}.}, label={lst:preferenzelp}]
#minimize{
	-1@4,
	Matricola :
		garante(docente(Matricola), corso(Corso)),
		presidente(docente(Matricola), corso(Corso))
}.

#minimize{
	-1@2,
	Matricola :
		garante(docente(Matricola), corso(Corso)),
		indeterminato(docente(Matricola))
}.

ideale(corso(Corso)) :-
	N=#count{
		docente(Matricola) :
		garante(docente(Matricola), corso(Corso)),
		indeterminato(docente(Matricola))
	},
	corso(Corso),
	max_garanti(Max, corso(Corso)),
	N=Max.

#minimize{
	-1@3,
	ideale(corso(Corso)) :
	ideale(corso(Corso))
}.

non_ideale(corso(Corso)) :-
	N=#count{
		docente(Matricola) :
		garante(docente(Matricola), corso(Corso)),
		indeterminato(docente(Matricola))
	},
	corso(Corso),
	max_garanti(Max, corso(Corso)),
	N<Max.

#minimize{
	1@1,
	non_ideale(corso(Corso)) :
	non_ideale(corso(Corso))
}.

#show ideale/1.
\end{lstlisting}\todo{aggiornare con versione definitiva}
\end{center}



\subsection{Complessità computazionale}

\section{Risultati}

\section{Conclusione}

\bibliographystyle{IEEEtran}
\bibliography{main}






\end{document}
